Cpp-Util

This is a collection of some data structures I have been working on recently.

My MPMC queue is (as of now) being schooled by boost's. HOWEVER, this is due
to the lack of atomic shared pointer support in the current development
toolkits. To work around this I had to use locking, which really took
the "lockfree" out of "lockfree queue." The hazard pointers should
bring me back ahead of boost's implementation (I hope). Results appended to
README.

Requires cmake 2.6+ and a c++11 supporting compiler.

Requires boost installed and available in system headers.

To run tests:
cmake . # specify -DCMAKE_CXX_COMPILER=... if it's not g++
make -j`nproc`
ctest -j`nproc`

Other cmake options are:
-DCMAKE_BUILD_TYPE=(debug|release) - specifies build setting
-DASSERTIONS_ON=(1|0) - specifies whether to turn on assertions, on by default for debug
  and off by default for release (this flag overrides those defaults).
        
For quick building and testing, use "chmod 700 build-and-test.sh"
Then ./build-and-test.sh

TODO:
        hazard_ptr structure (http://www.drdobbs.com/lock-free-data-structures-with-hazard-po/184401890) -> Note Retire() is called only with 1 thread, else double delete!! That's when you're certain
you have ownership (i.e. you got a successfull cas that moved the head forward). Future improvements to hazard pointers would be a global GC mechanism.  See if you can provide a typesafe interface to HPs with templates backed by void* pHazard list...
        hazard_queue (same as shared_queue, but instead of shared_ptr use hazard_ptr, also empty can use head == tail + invalid)
        check hazard_queue vs shared_queue
        try using spinlocks instead of mutexes in the atomic_shared_ptr (the lock doesn't have to protect much, so it's probably better if you generate a lot of atomic_shared_ptrs).
        document throws for pthreads (look at the "too many readers" return val, maybe spin?)
        asserts compute EVERYTHING, even if nothing is printed. Figure it out.
        cache and fibheap are terribly slow. speed them up.
        minimal flag parser
        suffix tries + ukkonen construct
        implement SingularThreadpool (1t) (mpsc)
        WorkStealingThreadpool # (using mpmc for each thread)
        clean up TODOs in code
        create test-testandset spinlock, and then queuelock (with everyhting, Art of mpp ch.7) 
        Test against boost spinlock
	concurrent heap_cache (finish testing & debugging)
	exact_heap_cache (see lfu_cache.h) - make separate method in main for comparison/stress
	linked_cache (see lfu_cache.h)
	-> concurrent versions of exact_heap_cache and linked_cache (clean up the entire mess)
	fibheap (check file for TODOs)
	valgrind check everything
        speed up assertions (worth it?)
	Use a lazily updated bool instead of insert_version_ and remove_version to denote "empty" in shared_queue.h

(Run `./release/mpmc-test.exe bench boost`)

Boost Queue
	Enqueues (8x100000): 131ms
	Dequeues (8x100000): 83ms
	Fair mpmc (~1000000 items, 4 enq, 4 deq): 204ms
	Enqueue-weighted mpmc (~1000000 items, 6 enq, 2 deq): 222ms
	Dequeue-weighted mpmc (~1000000 items, 2 enq, 6 deq): 182ms

Shared Queue
	Enqueues (8x100000): 633ms
	Dequeues (8x100000): 735ms
	Fair mpmc (~1000000 items, 4 enq, 4 deq): 1164ms
	Enqueue-weighted mpmc (~1000000 items, 6 enq, 2 deq): 983ms
	Dequeue-weighted mpmc (~1000000 items, 2 enq, 6 deq): 1196ms
